import"string.kc"

#pragma link("mega65hyper.ld")

const char* RASTER =0xd012;
const char* VIC_MEMORY = 0xd018;
const char* SCREEN = 0x0400;
const char* BGCOL = 0xd021;
const char* COLS = 0xd800;
const char BLACK = 0;
const char WHITE = 1;


unsigned char *current_screen_line = $0400;
unsigned char current_screen_x = 0;



void main(){
     
 }
 
 void exit_hypervisor() {
 *(unsigned char*)$D67F = $01;
 }
 
 void print_to_screen(char *message){
 while(*message){
   *(current_screen_line + current_screen_x) = *message++;
   current_screen_x++;}
 }
 
 void print_raster_lines (){
 		while(true){
			if(*RASTER==54 || *RASTER==66){
				*BGCOL = WHITE;
				} else {
					*BGCOL = BLACK;
					}
 }

 }
 
 void print_newline(){
   current_screen_line += 40;
   current_screen_x = 0;
 }
 				
	void reset(){
		*VIC_MEMORY = 0x14;
	//Fill the screen with spaces
	memset(SCREEN, ' ', 40*25);
	//Set the colour of every character on the screen to white
	memset(COLS,WHITE, 40*25);
	
	print_to_screen("chen1616 operating system starting...");
	print_newline();
	print_to_screen("testing hardware");
	print_newline();
	detect_devices();
  while(true){}
			
			}	
			

void print_hex(unsigned short value){
	
	char[5] hex;
	unsigned char i;
	for(i=0;i<4;i++){
		if(value<0xa000) hex[i]='0'+(char) (value>>12);
		else hex[i]=(char)(value>>12)-9;
		value<<=4;
	}
	hex[4]=0;
	print_to_screen(hex);
	}
	
	void test_memory(){
  unsigned short mem_start = $0800;
  unsigned short mem_end = $8000;
  volatile unsigned char *p;
  byte flag = 0;

   for(p=$0800; p <$8000; p++){    //test each memory location
   for (byte i = 0; i < 255; i++){   //test each value of a byte (0-255)
   *p = 1;
 
   if(*p != i){          //checks if values returned from *p is the same as saved
   flag = 1;
   print_to_screen("memory error at $");
   print_hex((unsigned short)p);
   print_newline();
   break;}
   }
   if(flag==1) break;    //update mem_end for successful memory check at this address
   mem_end = p;}
	print_to_screen("memory found at $");
	print_hex(mem_start);
	print_to_screen(" -$ ");
	print_hex((unsigned short)p);
	}
	

	
	
	
	
  void detect_devices(){
  
  unsigned short add_start = $D000;
  unsigned short add_end = $DFF0;
  volatile unsigned short i;
  volatile unsigned short j;
  //set memory locations in steps of 10 addresses
  for(i= $D000; i< $DFF0 ; i++){
  if( detect_vicii(i) == $7F){    //if return 1 , this means the device has been found 
  add_end=i;
  print_to_screen("vic-ii detected  at $");
	print_hex(add_start);
	print_to_screen(" -- $ ");
	print_hex(add_start+$7F);
	print_newline();}
	break;
  }
  
  for(j=$DC00; i< $DDFF; j++){
  if(mos6526(j)==1){
  print_to_screen("mos6526 detected  at $");
  print_hex((add_start+ $C00));
  print_to_screen(" -- $ ");
	print_hex(add_start +$CFF);
	print_newline();
	break;}
  }
  
  for(j=$DD00; i< $DDFF; j++){
  if(mos6526(j)==1){
  print_to_screen("mos6526 detected  at $");
  print_hex((add_start+ $D00));
  print_to_screen(" -- $ ");
	print_hex(add_start +$DFF);
	print_newline();
	break;}
  }
  
  

 print_to_screen("finished probing for devices");}
	
   unsigned short detect_vicii(unsigned short address){
   // Pointer where VIC-II is suspected to be
   volatile unsigned char *p;
	 unsigned char v1,v2;
	 word size = $7F;
	
	 unsigned short i;
	 v1=p[$12];        //Read start address +12 
	 for(i=1;i<1000;i++) continue;
	 v2=p[$12];     //Read again
	
	if(v2>v1){
	print_to_screen("vic-ii detected  at $");
  print_hex(address);
  print_to_screen(" -- $ ");
	print_hex(address+size);
	print_newline();
	 
	 }
	 return size;}
	 
	 
	 unsigned short mos6526(unsigned short address){
	 unsigned short t1=address+$09;
	 unsigned short t2=address+$0A;
	 unsigned short t3=address+$0B;
	 
	if(t3>0 && t3<24){
	print_to_screen("mos6526 detected  at $");
  print_hex(address);
  print_to_screen(" -- $ ");
	print_hex(address);
	print_newline();
	 }
	 return 1;
	 
	 }
	 
  void syscall00(){exit_hypervisor();}
  void syscall01(){exit_hypervisor();}
  void syscall02(){exit_hypervisor();}
	void syscall03(){exit_hypervisor();}
	void syscall04(){exit_hypervisor();}
	void syscall05(){exit_hypervisor();}
	void syscall06(){exit_hypervisor();}
	void syscall07(){exit_hypervisor();}
	void syscall08(){exit_hypervisor();}
	void syscall09(){exit_hypervisor();}
	void syscall10(){exit_hypervisor();}
	void syscall11(){exit_hypervisor();}
	void syscall12(){exit_hypervisor();}
	void syscall13(){exit_hypervisor();}
	void syscall14(){exit_hypervisor();}
	void syscall15(){exit_hypervisor();}
	void syscall16(){exit_hypervisor();}
	void syscall17(){exit_hypervisor();}
	void syscall18(){exit_hypervisor();}
	void syscall19(){exit_hypervisor();}
	void syscall20(){exit_hypervisor();}
	void syscall21(){exit_hypervisor();}
	void syscall22(){exit_hypervisor();}
	void syscall23(){exit_hypervisor();}
	void syscall24(){exit_hypervisor();}
	void syscall25(){exit_hypervisor();}
	void syscall26(){exit_hypervisor();}
	void syscall27(){exit_hypervisor();}
	void syscall28(){exit_hypervisor();}
	void syscall29(){exit_hypervisor();}
	void syscall30(){exit_hypervisor();}
	void syscall31(){exit_hypervisor();}
	void syscall32(){exit_hypervisor();}
	void syscall33(){exit_hypervisor();}
	void syscall34(){exit_hypervisor();}
	void syscall35(){exit_hypervisor();}
	void syscall36(){exit_hypervisor();}
	void syscall37(){exit_hypervisor();}
	void syscall38(){exit_hypervisor();}
	void syscall39(){exit_hypervisor();}
	void syscall40(){exit_hypervisor();}
	void syscall41(){exit_hypervisor();}	
	void syscall42(){exit_hypervisor();}
	void syscall43(){exit_hypervisor();}
	void syscall44(){exit_hypervisor();}
	void syscall45(){exit_hypervisor();}
	void syscall46(){exit_hypervisor();}
  void syscall47(){exit_hypervisor();}
	void syscall48(){exit_hypervisor();}
	void syscall49(){exit_hypervisor();}
	void syscall50(){exit_hypervisor();}
	void syscall51(){exit_hypervisor();}
	void syscall52(){exit_hypervisor();}
	void syscall53(){exit_hypervisor();}
	void syscall54(){exit_hypervisor();}
	void syscall55(){exit_hypervisor();}
	void syscall56(){exit_hypervisor();}
	void syscall57(){exit_hypervisor();}
	void syscall58(){exit_hypervisor();}
	void syscall59(){exit_hypervisor();}
	void syscall60(){exit_hypervisor();}
	void syscall61(){exit_hypervisor();}
	void syscall62(){exit_hypervisor();}
	void syscall63(){exit_hypervisor();}
	
	void pagfault(){exit_hypervisor();}	
	void restorkey(){exit_hypervisor();}	
	void alttabkey(){exit_hypervisor();}	
	void vf011rd(){exit_hypervisor();}	
	void vf011wr(){exit_hypervisor();}	
	void reserved(){exit_hypervisor();}	
	void cpukil(){exit_hypervisor();}
     
 #pragma data_seg(Syscall) 
 struct SysCall{
     char xjmp;
     void()* syscall;
     char xnop;
 };
 
 const char JMP = 0x4c;
 const char NOP = 0xea;
 
export struct SysCall[] SYSCALLS = {
    { JMP, &syscall00, NOP},
    { JMP, &syscall01, NOP},
    { JMP, &syscall02, NOP},
    { JMP, &syscall03, NOP},
    { JMP, &syscall04, NOP},
    { JMP, &syscall05, NOP},
    { JMP, &syscall06, NOP},
    { JMP, &syscall07, NOP},
    { JMP, &syscall08, NOP},
    { JMP, &syscall09, NOP},
    { JMP, &syscall10, NOP},
    { JMP, &syscall11, NOP},
    { JMP, &syscall12, NOP},
    { JMP, &syscall13, NOP},
    { JMP, &syscall14, NOP},
    { JMP, &syscall15, NOP},
    { JMP, &syscall16, NOP},
    { JMP, &syscall17, NOP},
    { JMP, &syscall18, NOP},
    { JMP, &syscall19, NOP},
    { JMP, &syscall20, NOP},
    { JMP, &syscall21, NOP},
    { JMP, &syscall22, NOP},
    { JMP, &syscall23, NOP},
    { JMP, &syscall24, NOP},
    { JMP, &syscall25, NOP},
    { JMP, &syscall26, NOP},
    { JMP, &syscall27, NOP},
    { JMP, &syscall28, NOP},
    { JMP, &syscall29, NOP},
    { JMP, &syscall30, NOP},
    { JMP, &syscall31, NOP},
    { JMP, &syscall32, NOP},
    { JMP, &syscall33, NOP},
    { JMP, &syscall34, NOP},
    { JMP, &syscall35, NOP},
    { JMP, &syscall36, NOP},
    { JMP, &syscall37, NOP},
    { JMP, &syscall38, NOP},
    { JMP, &syscall39, NOP},
    { JMP, &syscall40, NOP},
    { JMP, &syscall41, NOP},
    { JMP, &syscall42, NOP},
    { JMP, &syscall43, NOP},
    { JMP, &syscall44, NOP},
    { JMP, &syscall45, NOP},
    { JMP, &syscall46, NOP},
    { JMP, &syscall47, NOP},
    { JMP, &syscall48, NOP},
    { JMP, &syscall49, NOP},
    { JMP, &syscall50, NOP},
    { JMP, &syscall51, NOP},
    { JMP, &syscall52, NOP},
    { JMP, &syscall53, NOP},
    { JMP, &syscall54, NOP},
    { JMP, &syscall55, NOP},
    { JMP, &syscall56, NOP},
    { JMP, &syscall57, NOP},
    { JMP, &syscall58, NOP},
    { JMP, &syscall59, NOP},
    { JMP, &syscall60, NOP},
    { JMP, &syscall61, NOP},
    { JMP, &syscall62, NOP},
    { JMP, &syscall63, NOP}
    };
    
export align(0x100) struct SysCall[] TRAPS = {
    {JMP, &reset, NOP},
    {JMP, &pagfault, NOP},
    {JMP, &restorkey, NOP},
    {JMP, &alttabkey, NOP},
    {JMP, &vf011rd, NOP},
    {JMP, &vf011wr, NOP},
    {JMP, &reserved, NOP},
    {JMP, &cpukil, NOP}
};     